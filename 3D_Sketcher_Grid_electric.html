<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>3D Sketcher — DEMO + Glow Fix + Multi Import</title>
  <style>
    html, body { height: 100%; }
    body { overflow: hidden; margin: 0; padding: 0;
      background: radial-gradient(1200px 800px at 50% 60%, #070b18 0%, #05060a 60%, #000 100%);
      color: #e6f7ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans"; }
    canvas { position: absolute; inset: 0; display: block; }
    .dg.ac { z-index: 10; }
    #hint { position: fixed; left: 12px; bottom: 12px; font-size: 12px; opacity: .9; pointer-events: none;
      text-shadow: 0 0 10px rgba(0,255,255,.4); line-height: 1.4; }
    kbd{background:#0f1a2e; border:1px solid #1e2b47; border-bottom-color:#0d1324; padding:2px 6px; border-radius:4px;}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="hint">
    <div>相機：<kbd>W/S</kbd> 縮放； <kbd>A/D</kbd> 左右環繞； <kbd>Q/E</kbd> 垂直移動</div>
    <div>滑鼠左鍵：畫線。<kbd>T</kbd>：切換 Demo。</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

  <script>
  (function () {
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    const cam = { theta:-1.6, phi:-0.2, radius:9000, velTheta:0, velPhi:0, damping:0.92,
      minPhi:-1.25, maxPhi:1.25, minR:400, maxR:20000, y:-4000 };

    function hslToRgb(h,s,l){ s/=100;l/=100;const k=n=>(n+h/30)%12;const a=s*Math.min(l,1-l);
      const f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
      return {r:Math.round(255*f(0)),g:Math.round(255*f(8)),b:Math.round(255*f(4))}; }
    function randomNeonColor(){ const hues=[190,200,210,220,160,280,300,330,20,45];
      const h=hues[(Math.random()*hues.length)|0]+(Math.random()*10-5);
      return hslToRgb((h+360)%360, 96, 62); }
    function mod(n,m){ return ((n % m) + m) % m; }

    function Line(points, color){ this.points=points||[]; this.dist=0;
      color=color||randomNeonColor(); this.rgb=color;
      this.color='rgb('+~~(color.r)+','+~~(color.g)+','+~~(color.b)+')'; this.anchorRiseY=riseOffsetY; }
    Line.prototype.update=function(){ const p=this.points[this.points.length-1]; this.dist=p?p.z:0; };
    
// ---- Electric jitter helpers (canvas approximation of SVG turbulence) ----
function _seededNoise(i, t, mix){ // mix in [0,1]
  // Cheap, fast noise: blend sin and cos with incommensurate frequencies
  const a = Math.sin(i*0.47 + t*1.73);
  const b = Math.cos(i*1.11 + t*2.13);
  const c = Math.sin(i*0.77 - t*0.89);
  return a*(1-mix) + 0.5*b*mix + 0.5*c*(1-mix);
}
function _pathNormals(pts){
  // Approximate per-vertex normals from neighboring points
  const n = new Array(pts.length);
  for(let i=0;i<pts.length;i++){
    const p0 = pts[Math.max(0,i-1)], p1 = pts[Math.min(pts.length-1,i+1)];
    const dx = p1.x - p0.x, dy = p1.y - p0.y;
    let nx = -dy, ny = dx;
    const len = Math.hypot(nx, ny) || 1;
    n[i] = {x:nx/len, y:ny/len};
  }
  return n;
}
function _jitterPath(pts, amp, t, mix){
  const out = new Array(pts.length);
  const norms = _pathNormals(pts);
  for(let i=0;i<pts.length;i++){
    const p = pts[i], no = norms[i];
    const n = _seededNoise(i, t, mix);
    // Tangential wobble
    const tx = -no.y, ty = no.x;
    const aN = amp * (0.7 + 0.3*Math.sin(i*0.33 + t*2.7));
    const aT = amp * 0.5 * (0.5 + 0.5*Math.cos(i*0.21 - t*1.9));
    out[i] = { x: p.x + no.x*aN*n + tx*aT*n, y: p.y + no.y*aN*n + ty*aT*n };
  }
  return out;
}
function _strokePath(ctx, pts){
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
}

    Line.prototype.render=function(ctxCore, _ctxGlow, translateY){
const lw=settings.lineWidth*DPR; const pts2=scratch2D; pts2.length=0;
for(let i=0;i<this.points.length;i++){ const p2=projectTo2DWithYOffset(this.points[i], translateY); if(p2) pts2.push(p2); }
if(pts2.length<2) return;

// "Electric" style (approximate SVG turbulence via multi-jittered strokes)
if (settings.electricMode) {
  const layers = Math.max(1, settings.electricLayers|0);
  const amp = (settings.electricAmp||6)*DPR;
  const mix = Math.max(0, Math.min(1, settings.electricNoiseMix||0.6));
  const t = __timeSec*(settings.electricSpeed||1.0);

  ctxCore.save();
  ctxCore.setTransform(1,0,0,1,0,0);
  ctxCore.lineCap='round'; ctxCore.lineJoin='round';
  ctxCore.globalCompositeOperation = 'lighter';

  // Subtle outer glow
  if (settings.enableGlow) {
    ctxCore.shadowBlur = (settings.glowStrength||8) * DPR;
    ctxCore.shadowColor = this.color;
  }

  for (let k=0;k<layers;k++){
    const layerAmp = amp * (1.0 - k/(layers*1.25));
    const jittered = _jitterPath(pts2, layerAmp, t + k*0.618, mix);
    ctxCore.globalAlpha = 0.35 + 0.5*Math.max(0, 1 - k/layers);
    ctxCore.lineWidth = lw * (1.0 + k*0.6);
    ctxCore.strokeStyle = this.color;
    _strokePath(ctxCore, jittered);
  }

  // Core pass to keep definition
  ctxCore.globalAlpha = 1;
  ctxCore.shadowBlur = 0;
  ctxCore.lineWidth = lw;
  ctxCore.strokeStyle = this.color;
  _strokePath(ctxCore, pts2);
  ctxCore.restore();
  return;
}

// Existing glow + core pass (when not using electric mode)
if (settings.enableGlow) {
  ctxCore.save();
  ctxCore.setTransform(1,0,0,1,0,0);
  ctxCore.lineCap='round'; ctxCore.lineJoin='round';
  ctxCore.globalCompositeOperation = 'lighter';
  ctxCore.shadowBlur = (settings.glowStrength||8) * DPR;
  ctxCore.shadowColor = this.color;
  ctxCore.lineWidth = lw * 1.8;
  ctxCore.strokeStyle = 'rgba('+(this.rgb.r|0)+','+(this.rgb.g|0)+','+(this.rgb.b|0)+','+(settings.glowAlpha||0.45)+')';
  strokePath2D(ctxCore, pts2); ctxCore.stroke();
  ctxCore.restore();
}

// Core pass
ctxCore.save(); ctxCore.setTransform(1,0,0,1,0,0); ctxCore.lineCap='round'; ctxCore.lineJoin='round';
ctxCore.lineWidth=lw; ctxCore.strokeStyle=this.color; ctxCore.shadowBlur=0; ctxCore.globalAlpha=1;
strokePath2D(ctxCore, pts2); ctxCore.stroke(); ctxCore.restore();

    };
    function strokePath2D(ctx,pts){ ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y); }
    function PointWorld(x,y,z){ this.x=x||0; this.y=y||0; this.z=z||0; }
    function rotateY(v,a){ const c=Math.cos(a), s=Math.sin(a); return {x:v.x*c-v.z*s,y:v.y,z:v.z*c+v.x*s}; }
    function rotateX(v,a){ const c=Math.cos(a), s=Math.sin(a); return {x:v.x,y:v.y*c-v.z*s,z:v.z*c+v.y*s}; }
    function projectTo2DWithYOffset(p,yoff){ let v={x:p.x,y:p.y+(yoff||0)-cam.y,z:p.z};
      v=rotateY(v,-cam.theta); v=rotateX(v,-cam.phi); v.z+=cam.radius; const scale=focal/(focal+v.z); if(scale<=0) return null;
      return {x:vpx+v.x*scale, y:vpy+v.y*scale}; }
    function screenToWorldOnPlane(sx,sy,drawPlaneZ){ const scaleInv=(focal+drawPlaneZ)/focal;
      const x_cam=(sx-vpx)*scaleInv; const y_cam=(sy-vpy)*scaleInv; const z_cam=drawPlaneZ;
      let v=rotateX({x:x_cam,y:y_cam,z:z_cam}, +cam.phi); v=rotateY(v, +cam.theta); return new PointWorld(v.x, v.y+cam.y, v.z); }

    const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d',{alpha:true});
    let lines=[], focal=0, vpx=0, vpy=0,
        settings={ 
electricMode:false, electricLayers:3, electricAmp:6, electricSpeed:1.25, electricNoiseMix:0.6,
strokeColor:randomNeonColor(), lineWidth:0.9, demoMode:false, trailAlpha:0.16, orbitStep: 0.002, // ← 新增：左右旋轉速度（越小越慢）
                   maxLines:1200, maxPointsPerLine:60000, minSegmentLen:0.2,
                   riseSpeed:2, followRatio:0.35, drawPlaneZ:1200,
                   demoPointsPerFrame: 9, demoStepAmplitude: 900, demoNewLineChance: 0.96, demoPad: 24, demoFullScreen: false,
                   showFloor:true, showRightWall:true, gridStep:240, gridCell:600, gridHalf:10000, gridYRange:90000,
                   gridThin:'rgba(70,160,220,0.20)', gridThick:'rgba(130,210,255,0.45)', gridLabel:'rgba(190,230,255,0.9)', gridFontPx:16,
                   enableGlow:false, glowStrength:9, glowAlpha:0.55,
                   clearScreen(){ lines.length = 0; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); } },
        painting=false, points=[], line=null;
    const scratch2D=[]; let riseOffsetY=0;
    let __timeSec=0, __frame=0;


    function resize(){ const w=Math.floor(window.innerWidth), h=Math.floor(window.innerHeight);
      canvas.style.width=w+'px'; canvas.style.height=h+'px'; canvas.width=w*DPR; canvas.height=h*DPR;
      focal=Math.max(canvas.width, canvas.height)/2; vpx=canvas.width/2; vpy=canvas.height/2;
      ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); }
    window.addEventListener('resize', resize); resize();

    const keys={w:false,s:false,a:false,d:false,q:false,e:false,t:false}; const KEYMAP={87:'w',83:'s',65:'a',68:'d',81:'q',69:'e',84:'t'};
    const zoomStep=40*DPR, yStep=60*DPR;  // orbitStep 改由 settings.orbitStep 控制
    window.addEventListener('keydown', e=>{ 
      const k=KEYMAP[e.keyCode]; 
      if(k&&keys[k]!==undefined){ keys[k]=true; e.preventDefault(); }
      if(e.keyCode===84){ // T toggle demo
        settings.demoMode = !settings.demoMode;
        if(settings.demoMode) line=null;
      }
    });
    window.addEventListener('keyup', e=>{ const k=KEYMAP[e.keyCode]; if(k&&keys[k]!==undefined){ keys[k]=false; e.preventDefault(); }});

    const mouse={down:false};
    canvas.addEventListener('mousedown', e=>{
      if(e.button!==0) return; settings.demoMode=false; mouse.down=true; painting=true;
      const rect=canvas.getBoundingClientRect(); const startX=(e.clientX-rect.left)*DPR; const startY=(e.clientY-rect.top)*DPR;
      points=[]; line=new Line(points, randomNeonColor()); lines.push(line); if(lines.length>settings.maxLines) lines.splice(0, lines.length-settings.maxLines);
      addPointWorldFromScreen(startX, startY);
    });
    window.addEventListener('mouseup', ()=>{ mouse.down=false; painting=false; line=null; });
    canvas.addEventListener('mousemove', e=>{
      if(!mouse.down||!line) return; const rect=canvas.getBoundingClientRect();
      const x=(e.clientX-rect.left)*DPR; const y=(e.clientY-rect.top)*DPR; addPointWorldFromScreen(x,y);
    });
    function addPointWorldFromScreen(sx,sy){ const L=line.points.length; const world=screenToWorldOnPlane(sx,sy,settings.drawPlaneZ*DPR);
      if(L>0){ const last=line.points[L-1]; const dx=world.x-last.x, dy=world.y-last.y, dz=world.z-last.z;
        if(dx*dx+dy*dy+dz*dz < (settings.minSegmentLen*settings.minSegmentLen)) return; } line.points.push(world); }

    // ---------- Demo helpers ----------
    function startDemoLine() {
      points = [];
      line = new Line(points, randomNeonColor());
      lines.push(line);
      if (lines.length > settings.maxLines) lines.splice(0, lines.length - settings.maxLines);

      if (settings.demoFullScreen) {
        const pad = Math.max(0, (settings.demoPad|0)) * DPR;
        const sx = pad + Math.random() * (canvas.width - pad * 2);
        const sy = pad + Math.random() * (canvas.height - pad * 2);
        const world0 = screenToWorldOnPlane(sx, sy, settings.drawPlaneZ * DPR);
        line.points.push(world0);
      } else {
        line.points.push(new PointWorld(
          (Math.random()-0.5) * settings.demoStepAmplitude * DPR,
          0,
          (Math.random()-0.5) * settings.demoStepAmplitude * DPR
        ));
      }
    }

    // ---------- Grid ----------
    function drawFloorAndRightWall(){ const step=settings.gridStep*DPR, cell=settings.gridCell*DPR, half=settings.gridHalf*DPR, yRange=settings.gridYRange*DPR;
      const baseY=-(riseOffsetY % step);
      if(settings.showFloor){ for(let x=-half;x<=half;x+=cell){ const pA=projectTo2DWithYOffset({x,y:-300,z:-half},0), pB=projectTo2DWithYOffset({x,y:-300,z:half},0); if(pA&&pB) strokeGridLine(pA,pB,false); }
        for(let z=-half;z<=half;z+=cell){ const pA=projectTo2DWithYOffset({x:-half,y:-10,z},0), pB=projectTo2DWithYOffset({x:half,y:-10,z},0); if(pA&&pB) strokeGridLine(pA,pB,false);} }
      if(settings.showRightWall){ const wallX=half; for(let z=-half;z<=half;z+=cell){ const pA=projectTo2DWithYOffset({x:wallX,y:Math.min(-10,baseY-yRange),z},0);
          const pB=projectTo2DWithYOffset({x:wallX,y:Math.min(-10,baseY+yRange),z},0); if(pA&&pB) strokeGridLine(pA,pB,false); }
        const levels=Math.ceil((2*yRange)/step)+2;
        for(let i=-levels;i<=levels;i++){ const y=baseY+i*step; if(y>-10) continue; const idx=Math.round((riseOffsetY+y)/step);
          const labelVal=mod(idx,31); const isMajor=(labelVal%5===0);
          const pA=projectTo2DWithYOffset({x:wallX,y,z:-half},0), pB=projectTo2DWithYOffset({x:wallX,y,z:half},0); if(pA&&pB) strokeGridLine(pA,pB,isMajor);
          const labelPos=projectTo2DWithYOffset({x:wallX+200*DPR,y,z:half*0.6},0); if(labelPos&&y<=-10) drawLabel(labelPos.x,labelPos.y,labelVal); } } }
    function strokeGridLine(p1,p2,major){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
      ctx.lineWidth=(major?1.6:1.0)*DPR; ctx.strokeStyle=major?settings.gridThick:settings.gridThin; ctx.stroke(); ctx.restore(); }
    function drawLabel(x,y,val){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.font=(settings.gridFontPx*DPR)+'px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
      ctx.fillStyle=settings.gridLabel; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(String(val),x,y); ctx.restore(); }

    function loop(){
      if (keys.w) cam.radius -= zoomStep;
if (keys.s) cam.radius += zoomStep;
const orbit = (settings.orbitStep || 0.02);
if (keys.a) cam.velTheta -= orbit;
if (keys.d) cam.velTheta += orbit;
      if(keys.q) cam.y+=yStep; if(keys.e) cam.y-=yStep; cam.theta+=cam.velTheta; cam.velTheta*=cam.damping; cam.velPhi*=cam.damping;
      cam.phi=Math.max(cam.minPhi, Math.min(cam.maxPhi, cam.phi));
      if((painting || settings.demoMode) && !window.__IMPORTING){ riseOffsetY += settings.riseSpeed*DPR; cam.y -= settings.riseSpeed*settings.followRatio*DPR; }
      ctx.setTransform(1,0,0,1,0,0); ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1;
      ctx.fillStyle='rgba(0,0,0,'+settings.trailAlpha+')'; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawFloorAndRightWall();

      // --- Demo ---
      if (settings.demoMode && !window.__IMPORTING) {
        if (!line) {
          startDemoLine();
        } else {
          const last = line.points[line.points.length-1];
          const amp = settings.demoStepAmplitude * DPR;
          for (let k = 0; k < Math.max(1, (settings.demoPointsPerFrame|0)); k++) {
            const nx = last.x + (Math.random() - 0.5) * amp;
            const ny = last.y + (Math.random() - 0.5) * amp * 0.6;
            const nz = last.z + (Math.random() - 0.5) * amp;
            const world = new PointWorld(nx, ny, nz);
            const dx = world.x - last.x, dy = world.y - last.y, dz = world.z - last.z;
            if ((dx*dx + dy*dy + dz*dz) > (settings.minSegmentLen * settings.minSegmentLen)) {
              line.points.push(world);
            }
          }
          if (Math.random() > settings.demoNewLineChance) {
            line = null;
            settings.strokeColor = randomNeonColor();
          }
        }
      }

      const active=line; lines.sort((a,b)=>b.dist-a.dist); for(let i=0;i<lines.length;i++) lines[i].update();
      for(let i=0;i<lines.length;i++){ const ln=lines[i]; const yoff=(ln===active)?0:(riseOffsetY - ln.anchorRiseY); ln.render(ctx, null, yoff); }
      __frame++; __timeSec += 1/60; requestAnimationFrame(loop);
    }

    // GUI
    const gui=new dat.GUI(); 
    const camUI=gui.addFolder('Camera'); camUI.add(settings, 'orbitStep', 0.0001, 0.02, 0.001).name('左右旋轉速度').listen();
	camUI.add(cam,'radius',400,20000,10).name('鏡頭前後').listen();
    camUI.add(cam,'theta',-Math.PI,Math.PI,0.01).name('鏡頭左右').listen(); camUI.add(cam,'phi',-1.25,1.25,0.01).name('鏡頭仰角').listen(); camUI.add(cam,'y',-20000,20000,50).listen(); camUI.close();
    const drawUI=gui.addFolder('Draw'); drawUI.add(settings,'drawPlaneZ',200,3000,50).name('前方平面距離').listen(); drawUI.close();
    const look=gui.addFolder('Look');
    look.add(settings,'lineWidth',0.4,3,0.1).name('線寬(細)').listen();
    look.add(settings,'enableGlow').name('啟用微光').listen();
    look.add(settings,'glowStrength',0,50,1).name('微光強度').listen();
    look.add(settings,'glowAlpha',0.05,1,0.01).name('微光透明度').listen();
    
look.add(settings,'electricMode').name('電流線條(實驗)').listen();
look.add(settings,'electricLayers',1,6,1).name('電流層數');
look.add(settings,'electricAmp',0,20,0.5).name('電流幅度');
look.add(settings,'electricSpeed',0,3,0.05).name('電流速度');
look.add(settings,'electricNoiseMix',0,1,0.05).name('電流雜訊混合');

const misc=gui.addFolder('其他'); misc.add({clear:settings.clearScreen},'clear').name('清空'); misc.add(settings,'riseSpeed',0,10,0.1).name('上升速度');
    misc.add(settings,'followRatio',0,1.2,0.05).name('鏡頭跟隨比例'); misc.close();
    const demoUI = gui.addFolder('Demo');
    demoUI.add(settings, 'demoMode').name('Demo 模式');
    demoUI.add(settings, 'demoFullScreen').name('全版起筆');
    demoUI.add(settings, 'demoPointsPerFrame', 1, 40, 1).name('每幀點數').listen();
    demoUI.add(settings, 'demoStepAmplitude', 50, 2000, 10).name('步幅(世界)').listen();
    demoUI.add(settings, 'demoNewLineChance', 0.5, 0.995, 0.005).name('續畫機率').listen();
    demoUI.add(settings, 'demoPad', 0, 200, 1).name('邊界內縮').listen();

    window._sketchEnv={lines, settings, DPR, screenToWorldOnPlane, Line}; window.__IMPORTING=false;
    window._appendLine = function(points, color){
      const L = new Line(points.slice(), color || randomNeonColor());
      lines.push(L);
      return L;
    };
    loop();
  })();
  </script>

  <!-- Import/Export with progressive WORLD injection (no fan-out) -->
  <script>
  (function(){
    function ready(fn){ if(document.readyState!=='loading'){fn()} else {document.addEventListener('DOMContentLoaded',fn)} }
    ready(function(){
      const env = window._sketchEnv || {}; const DPR = env.DPR || window.devicePixelRatio || 1;

      function getCanvas(){ const cs=Array.from(document.querySelectorAll('canvas')).filter(c=>c.width>0&&c.height>0); return cs[0]||document.querySelector('canvas'); }
      function worldToScreen(wx,wy,z){ if(typeof window.screenToWorldOnPlane!=='function') return {sx:wx,sy:wy};
        let sx=wx, sy=wy, d=1.0; for(let i=0;i<10;i++){ const F=window.screenToWorldOnPlane(sx,sy,z); const ex=F.x-wx, ey=F.y-wy;
          if(!isFinite(ex)||!isFinite(ey)) break; if(Math.hypot(ex,ey)<0.5) break;
          const Fdx=window.screenToWorldOnPlane(sx+d,sy,z), Fdy=window.screenToWorldOnPlane(sx,sy+d,z);
          const j11=(Fdx.x-F.x)/d, j12=(Fdy.x-F.x)/d, j21=(Fdx.y-F.y)/d, j22=(Fdy.y-F.y)/d;
          const det=j11*j22-j12*j21; if(Math.abs(det)<1e-9){ sx-=ex; sy-=ey; continue; }
          const inv11=j22/det, inv12=-j12/det, inv21=-j21/det, inv22=j11/det; sx-=inv11*ex+inv12*ey; sy-=inv21*ex+inv22*ey; }
        return {sx, sy}; }
      function fire(type, el, x, y){ const opts={bubbles:true, clientX:x, clientY:y}; try{ el.dispatchEvent(new PointerEvent(type,opts)); }catch(e){} 
        const map={pointerdown:'mousedown', pointermove:'mousemove', pointerup:'mouseup'}; try{ el.dispatchEvent(new MouseEvent(map[type]||type,opts)); }catch(e){} }

      // UI
      const wrap=document.createElement('div'); wrap.style.cssText='position:fixed;left:12px;top:12px;z-index:99999;display:flex;gap:8px;align-items:center;flex-wrap:wrap';
      document.body.appendChild(wrap);
      function mkBtn(text){ const b=document.createElement('button'); b.textContent=text; b.style.cssText='padding:6px 12px;border:1px solid #888;background:#111;color:#fff;border-radius:6px;cursor:pointer'; wrap.appendChild(b); return b; }
      function mkChk(text, checked){ const l=document.createElement('label'); l.style.cssText='display:flex;align-items:center;gap:6px;color:#eee;font:12px sans-serif'; l.innerHTML='<input type="checkbox" '+(checked?'checked':'')+'> '+text; wrap.appendChild(l); return l.querySelector('input'); }
      function mkNum(text, val){ const l=document.createElement('label'); l.style.cssText='display:flex;align-items:center;gap:6px;color:#eee;font:12px sans-serif'; l.innerHTML=text+' <input type="number" step="1" value="'+val+'" style="width:90px;padding:4px 6px;background:#0b1220;border:1px solid #334;color:#dfe">'; wrap.appendChild(l); return l.querySelector('input'); }

      const btnImp = mkBtn('匯入');
      const btnExp = mkBtn('匯出');
      const chkClear = mkChk('匯入前清空', true);
      const chkProgress = mkChk('逐點重繪（注入）', true);
      const delayInput = 12;
      const gapInput =1200 ; // 保留 UI 但本版未使用
      const liftInput = mkNum('每檔Y位移(世界單位)', -500);

      const fileInput=document.createElement('input'); fileInput.type='file'; fileInput.accept='.json,application/json'; fileInput.multiple=true; fileInput.style.display='none'; document.body.appendChild(fileInput);
      btnImp.onclick=()=> fileInput.click();

      // 匯出（世界座標）
      btnExp.onclick = () => {
        try{
          const env = window._sketchEnv || {};
          const lines = window.lines || env.lines;
          const payload = { meta:{ type:'strokesWorld', app:'3D_Sketcher_Grid', dpr: window.devicePixelRatio, exportedAt:new Date().toISOString(), version:'demo_glow_fix' }, strokesWorld: [] };
          if (Array.isArray(lines)) {
            for (const L of lines) {
              const raw = Array.isArray(L?.points) ? L.points
                        : Array.isArray(L?.pts) ? L.pts
                        : Array.isArray(L?.vertices) ? L.vertices
                        : (typeof L?.getPoints === 'function' ? (L.getPoints() || []) : []);
              const pts = Array.isArray(raw) ? raw.map(p =>
                Array.isArray(p) ? {x:+p[0]||0, y:+p[1]||0, z:+p[2]||0}
                                 : {x:+p.x||0,  y:+p.y||0,  z:+p.z||0}
              ) : [];
              if (pts.length >= 2) {
                const entry = { points: pts };
                if (typeof L.color === 'string') entry.color = L.color;
                payload.strokesWorld.push(entry);
              }
            }
          }
          if (!payload.strokesWorld.length) { alert('目前沒有線條可匯出'); return; }
          const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'lines_export_' + Date.now() + '.json';
          document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(a.href), 1500);
        }catch(err){ console.error('[export]', err); alert('匯出失敗：' + err.message); }
      };

      fileInput.onchange = async (e) => {
        const files = Array.from(e.target.files || []);
        if(!files.length) return;
        try{
          const cvs=getCanvas(); if(!cvs){ alert('找不到 canvas'); return; }
          const env = window._sketchEnv || {};
          if(chkClear.checked){
            if(env.settings && typeof env.settings.clearScreen==='function') env.settings.clearScreen();
            if(Array.isArray(env.lines)) env.lines.length = 0;
          }

          const prevFollow = env.settings ? env.settings.followRatio : 0;
          if(env.settings) env.settings.followRatio = 0;
          window.__IMPORTING=true;

          const perPointDelay = Math.max(0, parseInt(delayInput.value)||0);
          const BASE_LIFT = (+liftInput.value || 0) * (env.DPR||1); // 世界座標單位
          const DRAW_Z = (env.settings?.drawPlaneZ || 1200) * (env.DPR||1);

          function mapStrokePoints(s, scaleDPR, extraY){
            const raw = Array.isArray(s.points)? s.points : [];
            const lift = extraY || 0;
            return raw.map(p => ({ x:(+p.x||0)*scaleDPR, y:(+p.y||0)*scaleDPR + lift, z:(p.z!=null? +p.z*scaleDPR : DRAW_Z) }));
          }

          async function injectProgressively(strokes, scaleDPR, fileLift){
            async function appendPointsToLine(lineObj, pts){
              for(let i=1;i<pts.length;i++){
                lineObj.points.push(pts[i]);
                await new Promise(r=>requestAnimationFrame(r));
                if(perPointDelay>0) await new Promise(r=>setTimeout(r, perPointDelay));
              }
            }
            for(const s of strokes){
              const pts = mapStrokePoints(s, scaleDPR, fileLift);
              if(pts.length>=2){
                const newL = env._appendLine ? env._appendLine([pts[0]]) : window._appendLine([pts[0]]);
                await appendPointsToLine(newL, pts);
              }
            }
          }

          let totalStrokes = 0;
          for(let i=0;i<files.length;i++){
            const f = files[i];
            const fileLift = (BASE_LIFT||0) * i;
            const text = await f.text();
            const data = JSON.parse(text);
            const strokes = Array.isArray(data?.strokesWorld)? data.strokesWorld : [];
            const exportDPR = (data.meta && +data.meta.dpr) || 1;
            const scaleDPR = exportDPR>0 ? (env.DPR / exportDPR) : 1;
            await injectProgressively(strokes, scaleDPR, fileLift);
            totalStrokes += strokes.length;
          }

          if(env.settings) env.settings.followRatio = prevFollow;
          window.__IMPORTING=false;
          for(const fn of ['tick','render','draw','animate','frame']){ if(typeof window[fn]==='function'){ try{ window[fn](); }catch(e){} } }
          alert('匯入完成：'+files.length+' 檔（總筆數約 '+totalStrokes+'）');
        }catch(err){
          console.error('[import]',err);
          alert('匯入失敗：'+err.message);
        } finally {
          e.target.value='';
          window.__IMPORTING=false;
        }
      };
    });
  })();
  </script>



<!-- ==== Injected: Import rise-per-point patch v4 (cumulative across lines) ==== -->
<script>
(function(){
  function getRisePerPoint(){
    const env = window._sketchEnv || {};
    const dpr = env.DPR || window.devicePixelRatio || 1;
    const speed = (env.settings && typeof env.settings.riseSpeed === 'number') ? env.settings.riseSpeed : 0;
    return speed * dpr;
  }

  // Keep last Y while importing so each new line starts where the previous left off.
  function ensureImportState(){
    if (window.__IMPORT_RISE_LAST_Y === undefined) window.__IMPORT_RISE_LAST_Y = null;
    if (window.__IMPORT_RISE_ACTIVE === undefined) window.__IMPORT_RISE_ACTIVE = false;
  }

  function wrapAppendLine(){
    const origAppend = window._appendLine;
    if (!origAppend || window._appendLine.__wrappedRiseV4) return;

    window._appendLine = function(points, color){
      ensureImportState();
      const importing = !!window.__IMPORTING;
      const rise = getRisePerPoint();
      const pts = Array.isArray(points) ? points.map(p => ({x:p.x, y:p.y, z:p.z})) : [];
      const line = origAppend.call(this, pts, color);

      if (importing && line && Array.isArray(line.points) && !line.points.__pushWrappedRiseV4) {
        window.__IMPORT_RISE_ACTIVE = true;

        // 1) For the very first point of this line: continue from the last imported Y if present
        if (line.points.length >= 1) {
          const first = line.points[0];
          if (window.__IMPORT_RISE_LAST_Y == null) {
            // First line of this import batch: seed from its own y
            window.__IMPORT_RISE_LAST_Y = first.y;
          } else {
            // Continue from previous line, step upward once
            first.y = window.__IMPORT_RISE_LAST_Y - rise;
            window.__IMPORT_RISE_LAST_Y = first.y;
          }
        }

        // 2) If initial array already had multiple points, chain them cumulatively upward
        for (let i = 1; i < line.points.length; i++) {
          line.points[i].y = line.points[i-1].y - rise;  // upward = decreasing Y
          window.__IMPORT_RISE_LAST_Y = line.points[i].y;
        }

        // 3) Intercept future pushes: always continue from last Y.
        const origPush = line.points.push.bind(line.points);
        line.points.push = function(p){
          const baseY = (window.__IMPORT_RISE_LAST_Y != null)
            ? window.__IMPORT_RISE_LAST_Y
            : (line.points.length ? line.points[line.points.length - 1].y : (p && p.y) || 0);
          const newPt = { x: p.x, y: baseY - rise, z: p.z };
          window.__IMPORT_RISE_LAST_Y = newPt.y;
          return origPush(newPt);
        };
        line.points.__pushWrappedRiseV4 = true;

        console.log('[import/rise v4] cumulative across lines enabled.');
      }

      return line;
    };

    window._appendLine.__wrappedRiseV4 = true;
    console.log('[import/rise v4] _appendLine wrapped (cumulative across lines).');
  }

  // Try to heuristically reset the LAST_Y after importing completes.
  function monitorImportFlag(){
    ensureImportState();
    if (!window.__IMPORT_RISE_ACTIVE) return;
    if (!window.__IMPORTING) {
      // Importing turned off -> reset state so manual drawing unaffected
      window.__IMPORT_RISE_LAST_Y = null;
      window.__IMPORT_RISE_ACTIVE = false;
      console.log('[import/rise v4] import finished, reset last Y.');
    }
    setTimeout(monitorImportFlag, 300);
  }

  function init(){
    try{ wrapAppendLine(); }catch(e){ console.warn(e); }
    // Monitor state
    setTimeout(monitorImportFlag, 300);
  }

  init();
  window.addEventListener('load', init);
  setTimeout(init, 300);
  setTimeout(init, 1200);
  setTimeout(init, 2500);
})();
</script>
<!-- ==== /Injected patch v4 ==== -->



  <!-- === Electric Border Overlay — CodePen Parameters + AURA & SPARK (強化版) === -->
  <svg id="eb-overlay-plus" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"
       style="position:fixed;inset:0;pointer-events:none;width:100%;height:100%;display:block;z-index:5;mix-blend-mode:screen">
    <defs>
      <!-- CodePen-exact filters -->
      <filter id="noise" x="-50%" y="-50%" width="200%" height="200%" filterUnits="objectBoundingBox">
        <feTurbulence id="turb1" type="turbulence" baseFrequency="0.05" numOctaves="2" result="turbulence"/>
        <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="50" xChannelSelector="R" yChannelSelector="G"/>
        <feDropShadow dx="0" dy="4" stdDeviation="0" flood-color="hsl(280 90% 80%)"/>
      </filter>
      <filter id="noise2" x="-50%" y="-50%" width="200%" height="200%" filterUnits="objectBoundingBox">
        <feTurbulence id="turb2" type="turbulence" baseFrequency="0.05" numOctaves="2" result="turbulence"/>
        <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="50" xChannelSelector="R" yChannelSelector="G"/>
        <feDropShadow dx="0" dy="2" stdDeviation="4" flood-color="hsl(10 90% 80%)"/>
      </filter>
      <!-- Soft aura blur -->
      <filter id="soft" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur stdDeviation="12" result="g"/>
        <feMerge>
          <feMergeNode in="g"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
  </svg>
  <script>
  (function(){
    const svg = document.getElementById('eb-overlay-plus');
    if(!svg) return;
    function sync(){
      const r = (document.scrollingElement||document.documentElement).getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio||1);
      svg.setAttribute('viewBox', `0 0 ${r.width*dpr} ${r.height*dpr}`);
      svg.setAttribute('width',  String(r.width*dpr));
      svg.setAttribute('height', String(r.height*dpr));
    }
    window.addEventListener('resize', sync, {passive:true});
    sync();

    // Seed thrashing at ~24fps (exact like the Pen) + subtle aura pulsing
    const turb1 = document.getElementById('turb1');
    const turb2 = document.getElementById('turb2');
    let seed = 0, last = 0, acc = 0, t = 0;
    function tick(ts){
      if(!last) last = ts;
      const dt = ts - last; last = ts; acc += dt; t += dt * 0.001;
      while(acc >= 1000/24){
        seed = (seed + 1) % 1000;
        if(turb1) turb1.setAttribute('seed', String(seed));
        if(turb2) turb2.setAttribute('seed', String((seed+10)%1000));
        acc -= 1000/24;
      }
      // Optional: gentle aura global pulse via CSS opacity
      const pulse = 0.85 + Math.sin(t*2.2) * 0.15;
      svg.style.opacity = String(Math.max(0.75, Math.min(1, pulse)));
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // ---- Monkey-patch only line rendering ----
    function rgbToHex(r,g,b){ const t=v=>('0'+(Math.max(0,Math.min(255,v|0))).toString(16)).slice(-2); return '#'+t(r)+t(g)+t(b); }
    const project = (function(){
      const cs=['projectTo2DWithYOffset','projectTo2DWithRise','projectTo2D','projectPointTo2D'];
      for(const k of cs){ if(typeof window[k]==='function') return window[k]; }
      if(window._sketchEnv && typeof window._sketchEnv.projectTo2D==='function') return window._sketchEnv.projectTo2D;
      return (p,y)=>({x:p.x,y:p.y});
    })();
    const DPR = Math.max(1, window.devicePixelRatio||1);

    function ensureGroup(line){
      if(line.__eb_plus) return line.__eb_plus;
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      // Four layers: AURA (soft), WARM (noise2), COOL (noise), SPARK (dash jitter)
      const aura = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const warm = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const cool = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const spark = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      [aura,warm,cool,spark].forEach(pl=>{
        pl.setAttribute('fill','none');
        pl.setAttribute('stroke-linecap','round');
        pl.setAttribute('stroke-linejoin','round');
      });
      aura.setAttribute('filter','url(#soft)');
      warm.setAttribute('filter','url(#noise2)');
      cool.setAttribute('filter','url(#noise)');
      g.appendChild(aura); g.appendChild(warm); g.appendChild(cool); g.appendChild(spark);
      svg.appendChild(g);
      line.__eb_plus = {g,aura,warm,cool,spark};
      return line.__eb_plus;
    }

    function jitterDash(el, base){
      const seg = base * (0.7 + Math.random()*0.7);
      const gap = base * (0.5 + Math.random()*0.9);
      el.setAttribute('stroke-dasharray', `${seg.toFixed(1)},${gap.toFixed(1)}`);
      el.setAttribute('stroke-dashoffset', (Math.random()*base*4).toFixed(1));
      el.setAttribute('opacity', (0.65 + Math.random()*0.35).toFixed(2));
    }

    const proto = (window.Line && window.Line.prototype) ? window.Line.prototype : null;
    if(proto && typeof proto.render==='function' && !proto.render.__EBplus){
      const orig = proto.render;
      proto.render = function(ctxCore, ctxGlow, translateY){
        const pts = this.points || this.pts || [];
        if(!pts || pts.length<2) return;
        const pts2 = [];
        for(let i=0;i<pts.length;i++){
          const p2 = project(pts[i], translateY||0);
          if(p2 && isFinite(p2.x) && isFinite(p2.y)) pts2.push(p2);
        }
        if(pts2.length<2) return;

        const d = pts2.map(p=>`${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
        const c = this.rgb || {r:120,g:210,b:255};
        const base = this.hex || rgbToHex(c.r||120,c.g||210,c.b||255);
        const warmHex = '#ffd2a8'; // close to hsl(10 90% 80%)
        const coolHex = '#d0b2ff'; // close to hsl(280 90% 80%)
        const lw = ((window.settings && window.settings.lineWidth) || 1) * DPR;

        const s = ensureGroup(this);
        // AURA (very thick/faint)
        s.aura.setAttribute('points', d);
        s.aura.setAttribute('stroke', base);
        s.aura.setAttribute('stroke-width', String(lw*4.2));
        s.aura.setAttribute('opacity', '0.35');

        // WARM displaced
        s.warm.setAttribute('points', d);
        s.warm.setAttribute('stroke', warmHex);
        s.warm.setAttribute('stroke-width', String(lw*2.6));

        // COOL displaced
        s.cool.setAttribute('points', d);
        s.cool.setAttribute('stroke', coolHex);
        s.cool.setAttribute('stroke-width', String(lw*1.7));

        // SPARK thin + dash jitter
        s.spark.setAttribute('points', d);
        s.spark.setAttribute('stroke', base);
        s.spark.setAttribute('stroke-width', String(Math.max(1, lw*0.9)));
        jitterDash(s.spark, Math.max(6, lw*8));
      };
      proto.render.__EBplus = true;

      try{
        if(window.settings && typeof window.settings.clearScreen==='function' && !window.settings.clearScreen.__EBplus){
          const _orig = window.settings.clearScreen.bind(window.settings);
          window.settings.clearScreen = function(){
            _orig();
            const defs = svg.querySelector('defs');
            Array.from(svg.children).forEach(ch=>{ if(ch!==defs) ch.remove(); });
          };
          window.settings.clearScreen.__EBplus = true;
        }
      }catch(e){}
    }
  })();
  </script>

</body>
</html>